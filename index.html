<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>WebRTC éŸ³è§†é¢‘é€šè¯</title>
  <style>
    body { font-family: Arial; padding: 20px; }
    video, audio { width: 100%; max-width: 480px; border: 1px solid #ccc; margin-top: 10px; display: none; }
    input, button, select { padding: 10px; margin: 5px 0; width: 100%; max-width: 480px; }
    #log { white-space: pre-wrap; color: #555; font-size: 14px; margin-top: 10px; background: #f7f7f7; padding: 10px; border: 1px dashed #ccc; }

    #incomingCallPopup {
      display: none;
      background: #fff;
      border: 1px solid #333;
      padding: 20px;
      max-width: 300px;
      position: fixed;
      top: 30%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 9999;
      box-shadow: 0 0 10px rgba(0,0,0,0.3);
      text-align: center;
    }
    #incomingCallPopup button {
      margin: 5px;
      padding: 8px 16px;
      width: auto;
    }
  </style>
</head>
<body>
  <h2>æˆ‘æ˜¯ç”¨æˆ·ï¼š<span id="myid">åŠ è½½ä¸­...</span></h2>
  <input type="text" id="targetId" placeholder="å¯¹æ–¹ID">
  <select id="callType">
    <option value="video">è§†é¢‘é€šè¯</option>
    <option value="audio">è¯­éŸ³é€šè¯</option>
  </select>
  <button onclick="startCall()">ğŸ“ å‘¼å«å¯¹æ–¹</button>
  <button onclick="hangup()">ğŸ”´ æŒ‚æ–­é€šè¯</button>

  <video id="localVideo" autoplay muted playsinline></video>
  <video id="remoteVideo" autoplay playsinline></video>
  <audio id="remoteAudio" autoplay></audio>

  <!-- æ¥ç”µå¼¹çª— -->
  <div id="incomingCallPopup">
    <p id="callerInfo">æœ‰ç”¨æˆ·å‘¼å«ä½ </p>
    <button onclick="acceptCall()">âœ… æ¥å¬</button>
    <button onclick="rejectCall()">âŒ æ‹’ç»</button>
  </div>

  <div id="log"></div>

  <script>
    const socket = new WebSocket("wss://zzy.dz12.top/wss");
    let myId = '';
    let peer = null;
    let localStream = null;
    let remoteStream = null;
    let incomingCall = null; // æ¥ç”µä¿¡æ¯

    function log(msg) {
      console.log(msg);
      document.getElementById('log').textContent += msg + "\n";
    }

    function status(msg) {
      document.getElementById('log').textContent += "ğŸŸ¢ " + msg + "\n";
    }

    socket.onopen = () => {
      status("å·²è¿æ¥åˆ°æœåŠ¡å™¨ âœ…");
    };

    socket.onmessage = async (e) => {
      const msg = JSON.parse(e.data);

      if (msg.type === 'init') {
        myId = msg.uid;
        document.getElementById('myid').innerText = myId;
        status(`åˆ†é…ç”¨æˆ·IDï¼š${myId}`);
      }

      if (msg.type === 'error') {
        alert("â— é”™è¯¯ï¼š" + msg.message);
        status("â— " + msg.message);
        return;
      }

      if (msg.type === 'offer') {
        incomingCall = msg;
        document.getElementById('callerInfo').innerText = `ğŸ“ ç”¨æˆ· ${msg.from} æ­£åœ¨å‘¼å«ä½  (${msg.data.callType === 'video' ? 'è§†é¢‘' : 'è¯­éŸ³'})`;
        document.getElementById('incomingCallPopup').style.display = 'block';
      }

      if (msg.type === 'answer') {
        status(`ğŸ“© æ”¶åˆ° ${msg.from} çš„åº”ç­”`);
        await peer.setRemoteDescription(new RTCSessionDescription(msg.data.offer));
      }

      if (msg.type === 'candidate') {
        if (peer) {
          await peer.addIceCandidate(new RTCIceCandidate(msg.data));
        }
      }

      if (msg.type === 'hangup') {
        status("ğŸ“´ å¯¹æ–¹å·²æŒ‚æ–­é€šè¯");
        cleanup();
      }
    };

    async function startCall() {
      const target = document.getElementById('targetId').value;
      const callType = document.getElementById('callType').value;
      if (!target) {
        alert("è¯·è¾“å…¥å¯¹æ–¹ID");
        return;
      }
      status(`æ­£åœ¨å‘¼å«ç”¨æˆ·ï¼š${target}ï¼ˆ${callType === 'video' ? 'è§†é¢‘' : 'è¯­éŸ³'}é€šè¯ï¼‰`);
      await createPeer(true, target, callType);
      const offer = await peer.createOffer();
      await peer.setLocalDescription(offer);
      socket.send(JSON.stringify({
        to: target,
        type: 'offer',
        data: { offer: offer, callType: callType }
      }));
    }

    async function createPeer(initiator, targetId, callType) {
      peer = new RTCPeerConnection();

      if (callType === 'video') {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        document.getElementById('localVideo').srcObject = localStream;
        document.getElementById('localVideo').style.display = 'block';
        document.getElementById('remoteVideo').style.display = 'block';
        document.getElementById('remoteAudio').style.display = 'none';
      } else {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        document.getElementById('localVideo').style.display = 'none';
        document.getElementById('remoteVideo').style.display = 'none';
        document.getElementById('remoteAudio').style.display = 'block';
      }

      localStream.getTracks().forEach(track => {
        peer.addTrack(track, localStream);
        console.log(`æ·»åŠ äº†ä¸€ä¸ªè½¨é“: ${track.kind}`);
      });

      peer.ontrack = (event) => {
        remoteStream = event.streams[0];
        if (callType === 'video') {
          document.getElementById('remoteVideo').srcObject = remoteStream;
          document.getElementById('remoteAudio').srcObject = null;
        } else {
          document.getElementById('remoteVideo').srcObject = null;
          document.getElementById('remoteAudio').srcObject = remoteStream;
        }
        status("ğŸ“º å·²è¿æ¥è¿œç¨‹è§†é¢‘/éŸ³é¢‘");
      };

      peer.onicecandidate = (e) => {
        if (e.candidate) {
          socket.send(JSON.stringify({
            to: targetId,
            type: 'candidate',
            data: e.candidate
          }));
        }
      };

      peer.onconnectionstatechange = () => {
        status(`è¿æ¥çŠ¶æ€: ${peer.connectionState}`);
      };
    }

    async function acceptCall() {
      const msg = incomingCall;
      document.getElementById('incomingCallPopup').style.display = 'none';
      incomingCall = null;

      const callType = msg.data.callType;
      await createPeer(false, msg.from, callType);
      await peer.setRemoteDescription(new RTCSessionDescription(msg.data.offer));
      const answer = await peer.createAnswer();
      await peer.setLocalDescription(answer);
      socket.send(JSON.stringify({
        to: msg.from,
        type: 'answer',
        data: { offer: answer, callType: callType }
      }));
      status("ğŸ“¤ å·²æ¥å¬å¹¶å‘é€åº”ç­” (answer)");
    }

    function rejectCall() {
      const msg = incomingCall;
      document.getElementById('incomingCallPopup').style.display = 'none';
      incomingCall = null;

      socket.send(JSON.stringify({
        to: msg.from,
        type: 'hangup',
        data: null
      }));
      status("âŒ å·²æ‹’ç»æ¥ç”µ");
    }

    function hangup() {
      if (peer) {
        const target = document.getElementById('targetId').value;
        socket.send(JSON.stringify({
          to: target,
          type: 'hangup',
          data: null
        }));
        status("ğŸ”´ å·²æŒ‚æ–­ï¼Œå‘é€ hangup æ¶ˆæ¯");
        cleanup();
      }
    }

    function cleanup() {
      if (peer) {
        peer.close();
        peer = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }
      document.getElementById('localVideo').srcObject = null;
      document.getElementById('remoteVideo').srcObject = null;
      document.getElementById('remoteAudio').srcObject = null;
    }
  </script>
</body>
</html>
